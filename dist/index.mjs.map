{"version":3,"sources":["../src/components/Skeletize.tsx"],"sourcesContent":["import { Box, Skeleton, SkeletonCircle, SkeletonText } from '@chakra-ui/react';\nimport React, { Children, cloneElement, isValidElement, ReactElement, useEffect, useRef, useState } from 'react';\n\nexport type SkeletizeProps = {\n  loading: boolean;\n  mode?: 'auto' | 'manual';\n  children: React.ReactNode;\n};\n\nconst getSkeletonProps = (\n  props: Record<string, any>,\n  excludeSize: boolean = true,\n  excludeDimensions: boolean = false,\n) => {\n  const allowed = [\n    'height',\n    'width',\n    'minHeight',\n    'minWidth',\n    'maxHeight',\n    'maxWidth',\n    'borderRadius',\n    'startColor',\n    'endColor',\n    'm',\n    'mt',\n    'mb',\n    'ml',\n    'mr',\n    'p',\n    'pt',\n    'pb',\n    'pl',\n    'pr',\n    'margin',\n    'padding',\n  ];\n\n  const skeletonProps: Record<string, any> = {};\n  for (const key of allowed) {\n    if (props[key] !== undefined) {\n      skeletonProps[key] = props[key];\n    }\n  }\n\n  // Build list of props to exclude\n  const propsToExclude: string[] = ['colorScheme', 'variant', 'onClick'];\n\n  // Only exclude size for buttons and other components where it conflicts\n  if (excludeSize) {\n    propsToExclude.push('size');\n  }\n\n  // Exclude dimensions when we're handling them manually\n  if (excludeDimensions) {\n    propsToExclude.push('height', 'width', 'minHeight', 'minWidth', 'maxHeight', 'maxWidth');\n  }\n\n  // Filter out excluded props\n  const cleanProps = { ...skeletonProps };\n  propsToExclude.forEach((prop) => {\n    delete cleanProps[prop];\n  });\n\n  return cleanProps;\n};\n\nconst getComponentName = (child: ReactElement): string => {\n  if (typeof child.type === 'string') return child.type;\n\n  const componentType = child.type as any;\n\n  // Check for displayName first\n  if (componentType && componentType.displayName) {\n    return componentType.displayName;\n  }\n\n  // Check for function name\n  if (componentType && componentType.name) {\n    return componentType.name;\n  }\n\n  // For forwardRef components, check the render function name\n  if (componentType && componentType.render) {\n    const renderFn = componentType.render;\n    if (renderFn && renderFn.displayName) return renderFn.displayName;\n    if (renderFn && renderFn.name) return renderFn.name;\n  }\n\n  // Check for $$typeof and other React internals (forwardRef, memo, etc.)\n  if (componentType && componentType.type) {\n    const innerType = componentType.type;\n    if (innerType && innerType.displayName) return innerType.displayName;\n    if (innerType && innerType.name) return innerType.name;\n  }\n\n  // Fallback to string representation and try to extract component name\n  const typeStr = componentType?.toString() || '';\n  const match = typeStr.match(/function\\s+([A-Za-z][A-Za-z0-9]*)/);\n  if (match) return match[1];\n\n  return '';\n};\n\nconst isAvatarLikeComponent = (child: ReactElement, name: string): boolean => {\n  // Check component name for Avatar patterns\n  if (['Avatar', 'ChakraAvatar', 'AvatarRoot', 'Avatar.Root'].includes(name)) return true;\n\n  // Check for avatar-like props (common in real Avatar components)\n  const hasAvatarProps = !!(\n    child.props.src ||\n    child.props.name ||\n    child.props.alt ||\n    child.props.fallback\n  );\n\n  // Check for circular appearance (borderRadius=\"full\" with equal width/height)\n  const isCircular = child.props.borderRadius === 'full' && child.props.w === child.props.h;\n\n  // Check for common avatar sizes\n  const hasAvatarSize =\n    child.props.size &&\n    typeof child.props.size === 'string' &&\n    ['xs', 'sm', 'md', 'lg', 'xl', '2xl'].includes(child.props.size);\n\n  return hasAvatarProps || (isCircular && hasAvatarSize);\n};\n\nconst isLayoutComponent = (name: string) =>\n  ['Box', 'Stack', 'Flex', 'Grid', 'Container', 'Wrap', 'Center'].includes(name);\n\nconst isTextLikeComponent = (child: ReactElement, name: string): boolean => {\n  // Check component name (including variations)\n  if (['Text', 'Heading', 'text', 'heading', 'ChakraText', 'ChakraHeading'].includes(name))\n    return true;\n\n  // Check for text-like props\n  const textProps = ['fontSize', 'fontWeight', 'color', 'textAlign', 'lineHeight', 'fontFamily'];\n  const hasTextProps = textProps.some((prop) => child.props[prop] !== undefined);\n\n  // Check if it contains only text content (string children)\n  const hasOnlyTextContent = typeof child.props.children === 'string';\n\n  // Check for common text styling props\n  const hasTextStyling = !!(\n    child.props.fontSize ||\n    child.props.fontWeight ||\n    child.props.color ||\n    child.props.textAlign ||\n    child.props.lineHeight ||\n    child.props.fontFamily ||\n    child.props.size // for Heading size prop\n  );\n\n  // If it has text content and any text/spacing props, treat as text\n  const hasTextOrSpacingProps = !!(\n    hasTextStyling ||\n    child.props.mb ||\n    child.props.mt ||\n    child.props.mx ||\n    child.props.my ||\n    child.props.margin ||\n    child.props.marginBottom ||\n    child.props.marginTop\n  );\n\n  // Return true if:\n  // 1. Name matches text components, OR\n  // 2. Has explicit text props, OR\n  // 3. Has text content AND has any text/spacing styling\n  return hasTextProps || (hasOnlyTextContent && hasTextOrSpacingProps);\n};\n\nconst isButtonLikeComponent = (child: ReactElement, name: string): boolean => {\n  // Check component name first - this is the most reliable\n  if (name === 'Button') return true;\n\n  // For Chakra UI, also check for common button component names\n  if (['ChakraButton', 'button'].includes(name)) return true;\n\n  // Check for button-specific props (avoid generic props like 'size')\n  return !!(\n    child.props.onClick ||\n    child.props.colorScheme ||\n    child.props.variant ||\n    child.props.type === 'button' ||\n    child.props.type === 'submit' ||\n    child.props.disabled !== undefined ||\n    child.props.isDisabled !== undefined ||\n    child.props.isLoading !== undefined ||\n    // Only consider size for buttons if it's combined with other button indicators\n    (child.props.size && (child.props.colorScheme || child.props.variant || child.props.onClick))\n  );\n};\n\nconst isLayoutLikeComponent = (child: ReactElement, name: string): boolean => {\n  // Check component name\n  if (isLayoutComponent(name)) return true;\n\n  // Check for layout-like props\n  const layoutProps = ['display', 'flexDirection', 'alignItems', 'justifyContent', 'gap'];\n  return layoutProps.some((prop) => child.props[prop] !== undefined);\n};\n\nexport const Skeletize: React.FC<SkeletizeProps> = ({ loading, mode = 'auto', children }) => {\n  if (!loading) return <>{children}</>;\n\n  const renderSkeletonForChild = (child: ReactElement): React.ReactNode => {\n    const name = getComponentName(child);\n    if (mode === 'manual') {      if (child.props['data-skeleton']) {\n        // In manual mode, still respect component types for proper skeleton rendering\n        // Check buttons FIRST to avoid conflicts with text detection\n        if (isButtonLikeComponent(child, name)) {\n          // Use the same recipe-aware approach for manual mode\n          const MeasuredSkeletonButton = () => {\n            const [dimensions, setDimensions] = useState<{width: number, height: number} | null>(null);\n            const measureRef = useRef<HTMLButtonElement>(null);\n\n            useEffect(() => {\n              if (measureRef.current) {\n                const rect = measureRef.current.getBoundingClientRect();\n                setDimensions({ width: rect.width, height: rect.height });\n              }\n            }, []);\n\n            const buttonProps = { ...child.props };\n            \n            // Remove interactive props and data-skeleton\n            delete buttonProps.onClick;\n            delete buttonProps.onMouseEnter;\n            delete buttonProps.onMouseLeave;\n            delete buttonProps.onFocus;\n            delete buttonProps.onBlur;\n            delete buttonProps.type;\n            delete buttonProps['data-skeleton'];\n\n            return (\n              <Box position=\"relative\" display=\"inline-block\">\n                {/* Invisible measuring button */}\n                {cloneElement(child, {\n                  ...buttonProps,\n                  ref: measureRef,\n                  position: 'absolute',\n                  opacity: 0,\n                  pointerEvents: 'none',\n                  zIndex: -1,\n                })}\n                \n                {/* Skeleton with measured dimensions */}\n                <Skeleton\n                  width={dimensions ? `${dimensions.width}px` : 'auto'}\n                  height={dimensions ? `${dimensions.height}px` : 'auto'}\n                  minWidth={dimensions ? `${dimensions.width}px` : '120px'}\n                  minHeight={dimensions ? `${dimensions.height}px` : '40px'}\n                  borderRadius=\"md\"\n                  display=\"inline-block\"\n                />\n              </Box>\n            );\n          };\n\n          return <MeasuredSkeletonButton />;\n        }\n        if (isTextLikeComponent(child, name)) {\n          // For text components, preserve size prop for SkeletonText\n          const props = getSkeletonProps(child.props, false);\n          return <SkeletonText noOfLines={1} {...props} />;\n        }\n        if (isAvatarLikeComponent(child, name)) {\n          // For avatars, exclude size since we handle it manually\n          const props = getSkeletonProps(child.props, true);\n          return (\n            <SkeletonCircle size={child.props.size || child.props.boxSize || '40px'} {...props} />\n          );\n        }\n        // Default to regular skeleton for other components\n        const props = getSkeletonProps(child.props, true);\n        return <Skeleton {...props} />;\n      }\n      if (isLayoutLikeComponent(child, name) && child.props?.children) {\n        return cloneElement(child, {\n          children: (\n            <Skeletize loading mode=\"manual\">\n              {child.props.children}\n            </Skeletize>\n          ),\n        });\n      }\n      return child;\n    }    // Enhanced component detection using both name and props\n    // Check buttons FIRST to avoid conflicts with text detection\n    if (isButtonLikeComponent(child, name)) {\n      // RECIPE-AWARE APPROACH: Use a measuring wrapper to get recipe-calculated dimensions\n      // This works with Chakra's recipe system by letting the button calculate its own size\n      \n      const MeasuredSkeletonButton = () => {\n        const [dimensions, setDimensions] = React.useState<{width: number, height: number} | null>(null);\n        const measureRef = React.useRef<HTMLButtonElement>(null);\n\n        React.useEffect(() => {\n          if (measureRef.current) {\n            const rect = measureRef.current.getBoundingClientRect();\n            setDimensions({ width: rect.width, height: rect.height });\n          }\n        }, []);\n\n        const buttonProps = { ...child.props };\n        \n        // Remove interactive props but keep all sizing props\n        delete buttonProps.onClick;\n        delete buttonProps.onMouseEnter;\n        delete buttonProps.onMouseLeave;\n        delete buttonProps.onFocus;\n        delete buttonProps.onBlur;\n        delete buttonProps.type;\n\n        return (\n          <Box position=\"relative\" display=\"inline-block\">\n            {/* Invisible measuring button - let recipe calculate correct size */}\n            {cloneElement(child, {\n              ...buttonProps,\n              ref: measureRef,\n              position: 'absolute',\n              opacity: 0,\n              pointerEvents: 'none',\n              zIndex: -1,\n            })}\n            \n            {/* Skeleton with measured dimensions */}\n            <Skeleton\n              width={dimensions ? `${dimensions.width}px` : 'auto'}\n              height={dimensions ? `${dimensions.height}px` : 'auto'}\n              minWidth={dimensions ? `${dimensions.width}px` : '120px'}\n              minHeight={dimensions ? `${dimensions.height}px` : '40px'}\n              borderRadius=\"md\"\n              display=\"inline-block\"\n            />\n          </Box>\n        );\n      };\n\n      return <MeasuredSkeletonButton />;\n    }\n\n    if (isTextLikeComponent(child, name)) {\n      // For text components, preserve size prop for SkeletonText\n      const props = getSkeletonProps(child.props, false);\n      return <SkeletonText noOfLines={1} {...props} />;\n    }\n\n    if (isAvatarLikeComponent(child, name)) {\n      // For avatars, exclude size since we handle it manually\n      const props = getSkeletonProps(child.props, true);\n      return <SkeletonCircle size={child.props.size || child.props.boxSize || '40px'} {...props} />;\n    }\n\n    if (name === 'Image') {\n      const props = getSkeletonProps(child.props, true);\n      return <Skeleton {...props} height={child.props.height || '200px'} />;\n    }\n\n    // Fallback: if name is empty but we have strong indicators\n    if (!name || name === '') {\n      // Check if this has text content and styling - likely a text component\n      if (\n        typeof child.props.children === 'string' &&\n        (child.props.fontSize || child.props.fontWeight || child.props.color)\n      ) {\n        const props = getSkeletonProps(child.props, false);\n        return <SkeletonText noOfLines={1} {...props} />;\n      }\n\n      // Check if this has button-like behavior\n      if (child.props.onClick || child.props.colorScheme || child.props.variant) {\n        // This looks like a button but we couldn't identify the component type\n        // Fall back to Box + Skeleton approach\n        const props = getSkeletonProps(child.props, true);\n        return (\n          <Box minH=\"40px\" minHeight=\"40px\" h=\"40px\" flexShrink={0} flex=\"0 0 auto\" display=\"block\">\n            <Skeleton {...props} height=\"40px\" width=\"120px\" />\n          </Box>\n        );\n      }\n    }\n\n    // Handle layout components that should wrap their children\n    if (isLayoutLikeComponent(child, name) && child.props?.children) {\n      return cloneElement(child, {\n        children: (\n          <Skeletize loading mode=\"auto\">\n            {child.props.children}\n          </Skeletize>\n        ),\n      });\n    }\n\n    // Default skeleton for components with explicit sizing or data-skeleton\n    const defaultProps = getSkeletonProps(child.props, true);\n    if (defaultProps.height || defaultProps.width || child.props['data-skeleton']) {\n      return <Skeleton {...defaultProps} />;\n    }\n\n    // Last resort: check if this looks like a button based on children content\n    if (typeof child.props.children === 'string') {\n      const content = child.props.children.toLowerCase();\n      const buttonKeywords = [\n        'click',\n        'submit',\n        'save',\n        'cancel',\n        'ok',\n        'yes',\n        'no',\n        'button',\n        'btn',\n      ];\n      if (buttonKeywords.some((keyword) => content.includes(keyword))) {\n        // This might be a button-like component, try the skeleton button approach\n        // But since we don't have access to a Button component here, fall back to Box + Skeleton\n        const props = getSkeletonProps(child.props, true);\n        return (\n          <Box minH=\"40px\" minHeight=\"40px\" h=\"40px\" flexShrink={0} flex=\"0 0 auto\" display=\"block\">\n            <Skeleton {...props} height=\"40px\" width=\"120px\" />\n          </Box>\n        );\n      }\n    }\n\n    // If we can't determine the component type, return as-is\n    return child;\n  };\n\n  return (\n    <>\n      {Children.map(children, (child) => {\n        if (!isValidElement(child)) return child;\n        return renderSkeletonForChild(child);\n      })}\n    </>\n  );\n};\n"],"mappings":"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","names":["props"]}